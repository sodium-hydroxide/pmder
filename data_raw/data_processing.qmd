
```{r}
# source("R/package_load.R")
# source("R/filenameAndParameters.R")
# source("R/cleanText.R")
# source("R/mcnpOutputParsing.R")
# package_load("tidyverse", "pracma")
# library(dplyr)



# This function returns all the tally data, the statistical checks, and checks
# for similarities in different tallies

parseMCNP <- function(
        fileNameList,
        numberOfBins,
        directory
) {

    # Subroutines ----
    
    drop_spaces <- function(
        string_vector# String to process
    ) {
        # This function removes all elements which are "" and elements which contain
        # any spaces
        
        # Remove blank characters
        string_vector <- string_vector[string_vector != ""]
        
        # Remove lines which contain spaces
        linesToKeep <- !(1:length(string_vector) %in% grep(" ",string_vector))
        
        string_vector <- string_vector[linesToKeep]
        return(string_vector)
    }
    
    rmna <- function(
        any_vector
    ) {
        return(any_vector[!is.na(any_vector)])
    }
    
    is_even <- function(
        input_int
    ) {
        return(input_int %% 2 == 0)
    }
    
    fileNameToParameters <- function(
        fileName # String
    ) {
        
        # Split file to find main parameters
        parameters <- strsplit(fileName, split = "_")[[1]]
        
        # Get the composition of the truck
        composition <- parameters[1]
        
        # Get the position of the truck
        truckPosition <- gsub("m", "-", parameters[2]) |> as.numeric()
        
        # Get the energy of the source
        energy <- gsub("dot", "\\.", parameters[3]) |> as.numeric()
        
        return(list(
            composition = composition,
            truckPosition = truckPosition,
            energy = energy
        ))
    }
    
    # Get results of statistical checks for a particular run
    getStatResults <- function(
        mcnpOutFile,
        directory
    ) {
        # Read output in as vector
        mcnpOutput <- as.vector(readLines(
            paste(directory, "/out_", mcnpOutFile, ".mcnpout", sep = "")
        ))
        
        # Obtain information about the runtime material, position, and energy
        runInfo <- mcnpOutFile |> fileNameToParameters()
        
        # Find index where tally summaries occur
        
        lineIndex <- which(grepl(
            "observed",
            mcnpOutput
        ))
        
        # Get lines of observed values for tally
        tallySummaries <- mcnpOutput[lineIndex]
        
        numberTallies <- length(tallySummaries)
        
        tallyID <- mcnpOutput[lineIndex - 6]
        
        statResults <- data.frame(
            Tally = rep("",numberTallies),
            Mean_B = rep("",numberTallies),
            RE = rep("",numberTallies),
            RE_Decrease = rep("",numberTallies),
            RE_Rate = rep("",numberTallies),
            VOV = rep("",numberTallies),
            VOV_Decrease = rep("",numberTallies),
            VOV_Rate = rep("",numberTallies),
            FOM = rep("",numberTallies),
            FOM_Behavior = rep("",numberTallies),
            PDFSlope = rep("",numberTallies)
        )
        
        # Get the tally being calculated and the value of each stat. test
        for (
            i in 1:length(tallySummaries)
        ) {
            # Save tally statistical tests values
            statResults[i,] <-
                (tallySummaries[i] |> strsplit(split = " "))[[1]] |>
                drop_spaces()
            
            # Save which tally is being used
            currentTally <-
                ((tallyID[i] |> strsplit(split = " "))[[1]] |> drop_spaces())
            
            statResults$Tally[i] <- currentTally[length(currentTally)]
        }
        
        # Save values for this particular run
        statResults <- cbind(data.frame(
            TruckMaterial = rep(runInfo$composition,numberTallies),
            Position = rep(runInfo$truckPosition,numberTallies),
            Energy = rep(runInfo$energy,numberTallies)
        ), statResults)
        
        # Rename tallies according to new naming convention
        statResults[statResults$Tally == "111",]$Tally <- "LF1"
        statResults[statResults$Tally == "121",]$Tally <- "LsF1"
        statResults[statResults$Tally == "112",]$Tally <- "LF2"
        statResults[statResults$Tally == "122",]$Tally <- "LsF2"
        statResults[statResults$Tally == "114",]$Tally <- "LF4"
        statResults[statResults$Tally == "124",]$Tally <- "LsF4"
        statResults[statResults$Tally == "118",]$Tally <- "LF8"
        statResults[statResults$Tally == "128",]$Tally <- "LsF8"
        statResults[statResults$Tally == "211",]$Tally <- "RF1"
        statResults[statResults$Tally == "221",]$Tally <- "RsF1"
        statResults[statResults$Tally == "212",]$Tally <- "RF2"
        statResults[statResults$Tally == "222",]$Tally <- "RsF2"
        statResults[statResults$Tally == "214",]$Tally <- "RF4"
        statResults[statResults$Tally == "224",]$Tally <- "RsF4"
        statResults[statResults$Tally == "218",]$Tally <- "RF8"
        statResults[statResults$Tally == "228",]$Tally <- "RsF8"
        
        return(statResults)
    }
    
    # Get the tally data for a section of an MCNP output file
    pullTallyData <- function(
        mcnpOutVector# Vector{String}, contains entire MCNP output
    ){
        # This function will pull the data from each tally and return a dataframe
        # containing vectors for the information
        # Function acts as subroutine for the processFiles function
        
        numberLines <- length(mcnpOutVector)
        
        energyVector <- rep(0,numberLines)
        tallyVector <- rep(0,numberLines)
        rsdVector <- rep(0,numberLines)
        
        # Loop over all lines. Get the energy, tally, and relative uncertainty
        for(
            i in 1:numberLines
        ){
            # Get current line, remove elements with spaces and blank elements
            currentLine <- strsplit(mcnpOutVector[i]," ")[[1]] |> drop_spaces
            
            energyVector[i] <- as.numeric(currentLine[1])
            tallyVector[i] <- as.numeric(currentLine[2])
            rsdVector[i] <- as.numeric(currentLine[3])
            
            # energyVector[i] <- (currentLine[1])
            # tallyVector[i] <- (currentLine[2])
            # rsdVector[i] <- (currentLine[3])
        }
        
        return(data.frame(
            measuredEnergy = energyVector,
            tallyValue = tallyVector,
            tallyRelUncert = rsdVector
        ))
    }
    
    # This function pulls all the tally data from a single MCNP run
    
    processFile <- function(
        mcnpOutFile, # String, location of mcnp string
        numBins, # Integer, number of bins for tallies
        directory # String, path to the file
    ){#
        # This function will process and MCNP output file given the path to the file
        # and the number of bins used for each tally. It will then return the
        # data into a csv file in the MCNPData directory.
        
        # Find Parameters for Run
        parameters <- fileNameToParameters(mcnpOutFile)
        
        # Find lines which correspond to start of tally ----
        mcnpOutput <- as.vector(readLines(
            paste(directory, "/out_", mcnpOutFile, ".mcnpout", sep = "")
        ))
        
        lineIndex = which(grepl("1tally    ",mcnpOutput))
        numberTallies <- length(lineIndex)
        
        tallyIndex <- data.frame(
            lineIndex=lineIndex,
            startPoint =rep(0,numberTallies),
            endPoint=rep(0,numberTallies),
            tallyType=rep("",numberTallies)
        )
        
        # Get the tally type, start, and end points ----
        
        # DataFrame for Tally Start and endpoints
        tallyStartLookup <- data.frame(
            monitor = c("1","1","1","1","1","1","1","1",
                        "2","2","2","2","2","2","2","2"),
            energy = c("1","1","1","1","2","2","2","2",
                       "1","1","1","1","2","2","2","2"),
            tallyType = c("1","2","4","8","1","2","4","8",
                          "1","2","4","8","1","2","4","8"),
            displacement = c(6,10,10,6,6,10,10,6,
                             6,10,10,6,6,10,10,6)
        )
        
        for(
            i in 1:numberTallies
        ){
            lineVal <- drop_spaces(
                strsplit(mcnpOutput[tallyIndex$lineIndex[i]]," ")[[1]]
            )[2]
            
            # Get the name I will be using for the tally
            tallyIndex$tallyType[i] <- paste0("F",lineVal)
            
            lineVal <- strsplit(lineVal,"")[[1]]
            
            # Lookup displacement in the tallyStartLookup
            displacement <- subset(tallyStartLookup,monitor==lineVal[1] &
                                       energy == lineVal[2] &
                                       tallyType == lineVal[3])$displacement[1]
            
            tallyIndex$startPoint[i] <- tallyIndex$lineIndex[i] + displacement
            
        }
        
        tallyIndex$endPoint <- tallyIndex$startPoint + numBins
        
        # Create Dataframe for MCNP output ----
        
        mcnpData <- data.frame(
            # ENERGY of Bin                    Tally Value                        Relative uncertainty
            EF111=rep(0,numBins+1),VF111=rep(0,numBins+1),UF111=rep(0,numBins+1),
            EF121=rep(0,numBins+1),VF121=rep(0,numBins+1),UF121=rep(0,numBins+1),
            EF112=rep(0,numBins+1),VF112=rep(0,numBins+1),UF112=rep(0,numBins+1),
            EF122=rep(0,numBins+1),VF122=rep(0,numBins+1),UF122=rep(0,numBins+1),
            EF114=rep(0,numBins+1),VF114=rep(0,numBins+1),UF114=rep(0,numBins+1),
            EF124=rep(0,numBins+1),VF124=rep(0,numBins+1),UF124=rep(0,numBins+1),
            EF118=rep(0,numBins+1),VF118=rep(0,numBins+1),UF118=rep(0,numBins+1),
            EF128=rep(0,numBins+1),VF128=rep(0,numBins+1),UF128=rep(0,numBins+1),
            EF211=rep(0,numBins+1),VF211=rep(0,numBins+1),UF211=rep(0,numBins+1),
            EF221=rep(0,numBins+1),VF221=rep(0,numBins+1),UF221=rep(0,numBins+1),
            EF212=rep(0,numBins+1),VF212=rep(0,numBins+1),UF212=rep(0,numBins+1),
            EF222=rep(0,numBins+1),VF222=rep(0,numBins+1),UF222=rep(0,numBins+1),
            EF214=rep(0,numBins+1),VF214=rep(0,numBins+1),UF214=rep(0,numBins+1),
            EF224=rep(0,numBins+1),VF224=rep(0,numBins+1),UF224=rep(0,numBins+1),
            EF218=rep(0,numBins+1),VF218=rep(0,numBins+1),UF218=rep(0,numBins+1),
            EF228=rep(0,numBins+1),VF228=rep(0,numBins+1),UF228=rep(0,numBins+1)
        )
        
        # Get tally data for data frame ----
        
        for(
            i in 1:numberTallies
        ){
            currentTallyType <- tallyIndex$tallyType[i]
            
            currentTallyData <- pullTallyData(
                mcnpOutput[tallyIndex$startPoint[i]:tallyIndex$endPoint[i]]
            )
            
            mcnpData[,paste0("E",currentTallyType)] <- currentTallyData$measuredEnergy
            mcnpData[,paste0("V",currentTallyType)] <- currentTallyData$tallyValue
            mcnpData[,paste0("U",currentTallyType)] <- currentTallyData$tallyRelUncert
        }
        
        # Check the energy bins are all correct and remove the energy bin data ----
        
        energyColumns <- c("EF111","EF121","EF112","EF122","EF114","EF124","EF118",
                           "EF128","EF211","EF221","EF212","EF222","EF214","EF224",
                           "EF218","EF228")
        
        energyBin <- magrittr::extract(mcnpData,(names(mcnpData) %in% energyColumns))
        
        mcnpData <- magrittr::extract(mcnpData,!(names(mcnpData) %in% energyColumns))
        
        energyBin <- energyBin$EF111
        
        # Rename columns ----
        names(mcnpData) <- c(
            "LF1","LF1_urel","LsF1","LsF1_urel","LF2","LF2_urel","LsF2","LsF2_urel",
            "LF4","LF4_urel","LsF4","LsF4_urel","LF8","LF8_urel","LsF8","LsF8_urel",
            "RF1","RF1_urel","RsF1","RsF1_urel","RF2","RF2_urel","RsF2","RsF2_urel",
            "RF4","RF4_urel","RsF4","RsF4_urel","RF8","RF8_urel","RsF8","RsF8_urel"
        )
        # Add data for the tally characteristics ----
        
        mcnpData <- 
            mcnpData |>
            dplyr::mutate(contents = parameters$composition) |>
            dplyr::relocate(contents, .before = LF1) |>
            dplyr::mutate(d_cm = parameters$truckPosition) |>
            dplyr::relocate(d_cm, .before = LF1) |>
            dplyr::mutate(Es_MeV = parameters$energy) |>
            dplyr::relocate(Es_MeV, .before = LF1) |>
            dplyr::mutate(Ed_MeV = energyBin) |>
            dplyr::relocate(Ed_MeV, .before = LF1)
        
        return(mcnpData)
        
    }
    
    # This function pulls all the tally data from a series of MCNP runs
    batchReadData <- function(
        fileNameList, # Text file with List of files to process
        numberOfBins, # Integer, number of bins for tallies
        directory
    ){
        
        # This function will batch process MCNP input files
        
        # Convert list of filenames to vector
        fileNameList <- paste(directory, "/", fileNameList, sep = "")
        fileNameList <- as.vector(readLines(fileNameList))
        
        allData <- processFile(
            fileNameList[1],
            numberOfBins,
            directory
        )
        
        for(
            i in 2:length(fileNameList)
        ){
            allData <- rbind(
                allData,
                processFile(
                    fileNameList[i],
                    numberOfBins,
                    directory
                )
            )
            print(i)
        }
        
        return(allData)
    }

    
    # Parse the input data as normal ----
    dataSet <- batchReadData(fileNameList,numberOfBins,directory) |>
        dplyr::mutate(
            contents = as.factor(contents),
            Es_keV = Es_MeV * 1000,
            Ed_keV = Ed_MeV * 1000,
            Es_MeV = NULL,
            Ed_MeV = NULL
        ) |>
        dplyr::relocate(Ed_keV, .before = LF1) |>
        dplyr::relocate(Es_keV, .before = Ed_keV)


    print("batchReadData Complete")
    # Get results of all tally statistics ----

    # Convert list of filenames to vector
    fileNameList <- as.vector(readLines(paste(
        directory, "/", fileNameList, sep = ""
    )))

    allStatResults <- getStatResults(
        fileNameList[1],
        directory
    )

    # Get tally statistics
    for (
        i in 2:length(fileNameList)
    ) {
        print(i)
        allStatResults <- rbind(
            getStatResults(
                fileNameList[i],
                directory
            ),
            allStatResults
        )
    }
    print("getStatResults Complete")

    # Clean up stat results to be tidy
    allStatResults <- allStatResults |>
        dplyr::mutate(MeanBehavior = Mean_B, Mean_B = NULL) |>
        dplyr::mutate(
            MeanBehaviorP = MeanBehavior == "constant",
            REP = as.numeric(RE) < 0.10,
            RE_DecreaseP = RE_Decrease == "yes",
            RE_RateP = RE_Rate == "yes",
            VOVP = as.numeric(VOV) < 0.10,
            VOV_DecreaseP = VOV_Decrease == "yes",
            VOV_RateP = VOV_Rate == "yes",
            FOMP = FOM == "constant",
            FOM_BehaviorP = FOM_Behavior == "random",
            PDFSlopeP = as.numeric(PDFSlope) > 3
        ) |>
        tidyr::pivot_longer(
            cols = c(
                "MeanBehavior", "RE", "RE_Decrease", "RE_Rate", "VOV", "VOV_Decrease",
                "VOV_Rate", "FOM", "FOM_Behavior", "PDFSlope"
            ),
            names_to = "Check",
            values_to = "Result"
        ) |>
        dplyr::mutate(
            MeanBehavior = MeanBehaviorP, MeanBehaviorP = NULL,
            RE = REP, REP = NULL,
            RE_Decrease = RE_DecreaseP, RE_DecreaseP = NULL,
            RE_Rate = RE_RateP, RE_RateP = NULL,
            VOV = VOVP, VOVP = NULL,
            VOV_Decrease = VOV_DecreaseP, VOV_DecreaseP = NULL,
            VOV_Rate = VOV_RateP, VOV_RateP = NULL,
            FOM = FOMP, FOMP = NULL,
            FOM_Behavior = FOM_BehaviorP, FOM_BehaviorP = NULL,
            PDFSlope = PDFSlopeP, PDFSlopeP = NULL
        ) |>
        tidyr::pivot_longer(
            cols = c(
                "MeanBehavior", "RE", "RE_Decrease", "RE_Rate", "VOV", "VOV_Decrease",
                "VOV_Rate", "FOM", "FOM_Behavior", "PDFSlope"
            ),
            names_to = "Check2",
            values_to = "Pass"
        ) |>
        filter(Check == Check2) |> dplyr::mutate(
            Check2 = NULL,
            contents = as.factor(TruckMaterial),
            d_cm = Position,
            Es_keV = Energy * 1000,
            TruckMaterial = NULL,
            Position = NULL,
            Energy = NULL
        ) |>
        dplyr::relocate(Es_keV) |>
        dplyr::relocate(d_cm) |>
        dplyr::relocate(contents)

    return(list(
        data = dataSet,
        tests = allStatResults
    ))

}












# Main output parsing
results <- parseMCNP(
    "listOfInputs.txt",
    200,
    "data_raw/truckPtSource"
)

stat_checks <- results$tests
spectral_data <- results$data

# Combining Useful Tallies to results ----

spectral_data <- spectral_data |>
    dplyr::mutate(
        F1 = 0.5 * (LF1 + RF1),
        uF1 = 0.5 * sqrt(
            ((LF1 * LF1_urel) ^ 2) +
                ((RF1 * RF1_urel) ^ 2)
        ),
        F2 = 0.5 * (LF2 + RF2),
        uF2 = 0.5 * sqrt(
            ((LF2 * LF2_urel) ^ 2) +
                ((RF2 * RF2_urel) ^ 2)
        ),
        F4 = 0.5 * (LF4 + RF4),
        uF4 = 0.5 * sqrt(
            ((LF4 * LF4_urel) ^ 2) +
                ((RF4 * RF4_urel) ^ 2)
        ),
        F8 = 0.5 * (LF8 + RF8),
        uF8 = 0.5 * sqrt(
            ((LF8 * LF8_urel) ^ 2) +
                ((RF8 * RF8_urel) ^ 2)
        ),
        y_cm = d_cm,
        d_cm = NULL
    )

# Absolute Efficiency Calculations ----

positions <- spectral_data |> pull(y_cm) |> unique()
energies <- spectral_data |> pull(Es_keV) |> unique()

summary <- data.frame(
    y_cm = rep(
        positions, times = length(energies)
    ),
    Es_keV = rep(
        energies, each = length(positions)
    )
)

summary <- rbind(
    summary |> dplyr::mutate(contents = "m"),
    summary |> dplyr::mutate(contents = "f")
) |> dplyr::mutate(
    PrReach = 0,
    uPrReach = 0,
    PrDet = 0,
    uPrDet = 0
)

rm(energies)
rm(positions)

spectral_data <- spectral_data |> dplyr::mutate(
    PrReach = F1,
    uPrReach = uF1,
    PrDet = F8,
    uPrDet = uF8
)

intrinsic_data <- results$intrinsic
for (i in 1:nrow(summary_data)) {
    currentSubset <- spectral_data |> filter(
        y_cm == summary_data$y_cm[i] &
            contents == summary_data$contents[i] &
            Es_keV == summary_data$Es_keV[i]
    )

    # Calculate probability of reaching detector

    summary_data$PrReach[i] <- sum(currentSubset$PrReach)
    summary_data$uPrReach[i] <- sqrt(sum(
        currentSubset$uPrReach ^ 2
    ))

    # Calculate probability of being detected
    summary_data$PrDet[i] <- sum(currentSubset$PrDet)
    summary_data$uPrDet[i] <- sqrt(sum(
        currentSubset$uPrDet ^ 2
    ))

    rm(currentSubset)
}
rm(i)

summary_data <- dplyr::mutate(summary_data, contents = as.factor(contents))

# Calculate count per decay of various sources ----
count_rate_data_discrete <- rbind(
    dplyr::mutate(
        count_rate(c(511), c(2), prob_data. = summary_data),
        source = "Beta-Plus"
    ),
    dplyr::mutate(
        count_rate(
            c(661.66), c(0.851),
            prob_data. = summary_data),
        source = "Cs-137"),
    dplyr::mutate(
        count_rate(
            c(1173.0, 1332.0), c(0.998, 0.999),
            prob_data. = summary_data),
        source = "Co-60"
    )
) |>
    dplyr::mutate(
        source = as.factor(source),
        contents = as.factor(contents)
    )


# Save data ----
save(spectral_data, file = "data/spectral_data.Rda")
save(stat_checks, file = "data/stat_checks.Rda")
save(summary_data, file = "data/summary_data.Rda" )
save(count_rate_data_discrete, file = "data/count_rate_data_discrete.R")












```


# Input Creation


```{r}

```


```{r}

# Running MCNP
mcnp_input_creation(
    1e3 * c(
        0.1400,0.2000,0.2500,0.3000,0.3500,0.4000,0.4500,0.5000,0.5110,0.5500,
        0.6000,0.6500,0.6616,0.7000,0.7500,0.8000,0.8500,0.9000,0.9500,1.0000,
        1.0220,1.0500,1.1000,1.1500,1.1730,1.2000,1.2500,1.3000,1.3320,1.3500,
        1.4000,1.4500,1.5000,1.5500,1.6000,1.6500,1.7000,1.7500,1.8000,1.8500,
        1.9000,1.9500,2.0000
    ), # Source energy (MeV)
    c(0, -250, -500, -750, -1000, -1250, -1500), # Displacements (cm)
    c("m", "f") # Truck Interior
)



# sh batchRun.sh

```


# Data Cleaning


```{r}


deck_list <- "listOfInputs.txt"
directory <- "data_raw/truckPtSource/"


# ----

mcnp_output_processing <- function(
        deck_list,
        directory) {
    
    output_list <- paste(
        "out_",
        readLines(paste(directory,deck_list, sep = "")),
        sep = ""
    )

    raw_data <- btools::mcnparse(
        output_list, directory = directory
    )



    # Data Cleaning ----
    stat_checks <- raw_data$check
    raw_data <- dplyr::mutate(
        raw_data$data,
        Ed_keV = bin_mev * 1000, bin_mev = NULL,
        Es_keV = 0,
        y_cm = 0,
        contents = ""
    )

    out = list(stat_check = stat_checks)

    for (i in 1:nrow(raw_data)) {
        run_id_i <- strsplit(raw_data$run_id[i], split = "_")[[1]]

        raw_data$contents[i] <- run_id_i[2]
        raw_data$y_cm[i] <- as.numeric(gsub("m", "-", run_id_i[3]))
        raw_data$Es_keV[i] <- 1000 * as.numeric(gsub("dot", ".", run_id_i[4]))

    }
    rm(i, run_id_i)

    for (tally in unique(raw_data$tally)) {
        label <- strsplit(tally, split = "")[[1]]

        if (label[1] == "1") {
            label[1] <- "L"
        }
        else {
            label[1] <- "R"
        }

        if (label[2] == "1") {
            label[2] <- "F"
        }
        else {
            label[2] <- "sF"
        }

        raw_data[raw_data$tally == tally,]$tally <- paste(label, collapse = "")

    }
    rm(tally, label)

    out$raw_data <- raw_data

    spectral_data <-
        raw_data |>
        dplyr::select(-run_id) |>
        dplyr::mutate(
            tally = as.factor(tally),
            contents = as.factor(contents)
        ) |>
        dplyr::filter(
            Ed_keV <= Es_keV + 10
        ) |>
        tidyr::pivot_wider(
            values_from = c(value, re),
            names_from = tally
        ) |>
        dplyr::mutate(
            F1 = 0.5 * (value_LF1 + value_RF1),
            uF1 = 0.5 * sqrt(
                ((re_LF1 * value_LF1) ^ 2) + ((re_RF1 * value_RF1) ^ 2)
            ),
            F2 = 0.5 * (value_LF2 + value_RF2),
            uF2 = 0.5 * sqrt(
                ((re_LF2 * value_LF2) ^ 2) + ((re_RF2 * value_RF2) ^ 2)
            ),
            F4 = 0.5 * (value_LF4 + value_RF4),
            uF4 = 0.5 * sqrt(
                ((re_LF4 * value_LF4) ^ 2) + ((re_RF4 * value_RF4) ^ 2)
            ),
            F8 = 0.5 * (value_LF8 + value_RF8),
            uF8 = 0.5 * sqrt(
                ((re_LF8 * value_LF8) ^ 2) + ((re_RF8 * value_RF8) ^ 2)
            ),
            PrReach = F1,
            uPrReach = uF1,
            PrDet = F8,
            uPrDet = uF8
        ) |>
        as.data.frame()

    out$spectral_data <- spectral_data

    # Creation of summary data ----

    all_Es_keV <- unique(spectral_data$Es_keV)
    num_Es_keV <- length(all_Es_keV)
    all_y_cm <- unique(spectral_data$y_cm)
    num_y_cm <- length(all_y_cm)
    all_contents <- unique(spectral_data$contents)
    num_contents <- length(all_contents)

    summary_data <- dplyr::mutate(
        data.frame(
            contents = rep(all_contents, each = num_y_cm * num_Es_keV),
            Es_keV =
                rep(rep(all_Es_keV, times = num_y_cm), times = num_contents),
            y_cm = rep(rep(all_y_cm, each = num_Es_keV), times = num_contents)
        ),
        PrReach = 0,
        uPrReach = 0,
        PrDet = 0,
        uPrDet = 0
    )

    rm(all_Es_keV, num_Es_keV, all_y_cm, num_y_cm, all_contents, num_contents)

    for (i in 1:nrow(summary_data)) {
        subset_i <- dplyr::filter(
            spectral_data,
            contents == summary_data$contents[i] &
                Es_keV == summary_data$Es_keV[i] &
                y_cm == summary_data$y_cm[i]
        )

        summary_data$PrReach[i] <- sum(subset_i$PrReach)
        summary_data$uPrReach[i] <- btools::rss(subset_i$uPrReach)

        summary_data$PrDet[i] <- sum(subset_i$PrDet)
        summary_data$uPrDet[i] <- btools::rss(subset_i$uPrDet)
        
    }
    rm(i, subset_i)
    
    out$summary_data <- summary_data


    # Return everything
    return(out)

}

a <- mcnp_output_processing("listOfInputs.txt", "data_raw/truckPtSource/")

#star F2
```


# Intrinsic Creation

# Linear Model

```{r}
# Construction of linear model ----


# Save data ----
save(linear_model,file = "data/linear_model.rda")
save(linear_model_beta, file = "data/linear_model_beta.rda")
save(count_rate_data_continuous, file = "data/count_rate_data_continuous.R")

```

# Earth Model


```{r}

save(earth_model, file = "data/earth_model.Rda")
save(earth_model_aug, file = "data/earth_model_aug.Rda")
```


    # Creation of linear model ----

    linear_model <- summary_data |>
        dplyr::mutate(
            cm = sqrt(y_cm^2 + 179.5 ^ 2),
            kev = Es_keV,
            y_cm = NULL,
            Es_keV = NULL,
            PrReach = NULL,
            uPrReach = NULL,
            actual = PrDet,
            PrDet = NULL,
            se_actual = uPrDet,
            uPrDet = NULL,
            trans_cm = log(cm),
            trans_kev = log(kev),
            trans_actual = log(actual),
            trans_se_actual = se_actual / actual,
            weight_trans = trans_se_actual ^ -2) |>
        lm(
            trans_actual ~ trans_cm + trans_kev + contents,
            data = _,
            weights = weight_trans)

    lm_val <- linear_model$coefficients[c(1,4,2,3)]
    lm_cov <- vcov(linear_model)[c(1,4,2,3),c(1,4,2,3)]
    lm_se <- sqrt(diag(lm_cov))
    lm_cor <- lm_cov / lm_se %*% t(lm_se)

    lm_df <- data.frame(cbind(
        lm_val, lm_se, lm_cor
    )) |>
        dplyr::mutate(type = c(
            "$\\hat{\\beta}_0$",
            "$\\hat{\\beta}_1$",
            "$\\hat{\\beta}_2$",
            "$\\hat{\\beta}_3$"
        )) |> relocate(type)

    linear_model_beta <- list(
        val = lm_val,
        se = lm_se,
        cov = lm_cov,
        cor = lm_cor,
        dataframe = lm_df
    )
    
    out$linear_regression <- list(
        linear_model = linear_model,
        linear_model_beta = linear_model_beta,
        linear_model_aug = broom::augment(linear_model)
    )
    

    # Creation of earth model ----

    earth_model_aug <- dplyr::mutate(
        summary_data,
        PrReach = NULL,
        uPrReach = NULL,
        trans_actual = log(PrDet),
        se_trans = uPrDet / PrDet,
        weight_trans_actual = se_trans ^ -2,
        PrDet = NULL,
        uPrDet = NULL)

    earth_model <- earth::earth(
        formula = (
            trans_actual
            ~ log(sqrt(as.numeric(y_cm)^2 + 179.5^2))
            + Es_keV + contents
            + Es_keV:contents
            + Es_keV:y_cm
            + log(sqrt(as.numeric(y_cm)^2 + 179.5^2)):contents),
        data = earth_model_aug,
        weights = weight_trans_actual,
        varmod.method = "earth",
        nfold = 2,
        ncross = 30)

    earth_model_aug <- dplyr::mutate(
        earth_model_aug,
        .fitted = earth_model$fitted.values,
        .resid = earth_model$residuals,
        .se.fitted = pull(
                    dplyr::mutate(
                        predict(earth_model,
                                interval = "cint",
                                level = 2 * pnorm(1) - 1),
                        se = 0.5 * (upr - lwr)),
                    se),
        .std.resid = .resid / sqrt(.se.fitted ^ 2 + se_trans ^ 2)
    )
    
    out$earth_regression <- list(
        earth_model = earth_model,
        earth_model_aug = earth_model_aug
    )
